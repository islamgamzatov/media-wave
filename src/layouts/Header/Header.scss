.header {
	position: sticky;
	z-index: 100; // z-index задает высоту этого «слоя». Это нужно, чтобы шапка всегда была поверх других блоков. Значение 100 — это условный запас, обычно его достаточно.
	top: 0; // Прибиваем header к верху страницы.
	width: 100%; // Когда элемент переходит в sticky-режим, он вырывается из обычного потока. width: 100% гарантирует, что он будет растягиваться на всю ширину своей родительской области, а не «схлопывается» до ширины своего содержимого.
	padding-block: fluid(22, 12);
	border-bottom: var(--border-width-s) solid transparent; // нужно, чтобы обеспечить плавное появление нижней границы
	animation-name: scrolling-header;
	animation-fill-mode: both; // Нужно, чтобы начальный и конечный ключевой кадр заморозились поле того, как анимация выполнилась.
	animation-timeline: scroll();
	animation-range: 0 100px;

	@keyframes scrolling-header {
		to {
			background-color: var(--color-black-08);
			border-color: var(--color-black-15);
			padding-block: 10px;
		}
	}

	&__inner {
		display: flex;
		justify-content: space-between;
		align-items: center;
		column-gap: 16px;
	}

	&__overlay-menu-dialog {
		position: fixed;
		inset: 0;
		flex-direction: column-reverse;
		row-gap: 16px;
		justify-content: start;
		width: 100%;
		height: 100%;
		padding: var(--container-padding-x); // У элемента dialog есть отступы по умолчанию, который также нужно сбросить.
		background-color: var(--color-black-20);
		border: none; // У элемента dialog есть border по умолчанию, который нужно скрыть.

		@include tablet-above {
			display: contents; // Значение contents у свойства display буквально говорит браузеру: «Представь, что у разметки на ширине экрана 1023px и выше не существует этой обертки»
		}

		&[open] { // селектор по атритубуту open.
			display: flex; // по умолчанию браузер скрывает <dialog>, используя свойство display: none. Когда диалог открыт, браузер меняет его на display: block. Когда вы вручную пишете в CSS .my-dialog { display: flex; }, вы перебиваете внутреннюю логику браузера. Чтобы сохранить flex и при этом позволить диалогу закрываться, нужно привязать display к состоянию диалога (наличию атрибута [open]).
		}
	}

	&__menu {
		border-radius: var(--border-radius-l);
		
		@include laptop {
			border-radius: var(--border-radius-m);
		}

		@include tablet-above {
			padding: fluid-to-laptop(10, 8);
			background-color: var(--color-black-06);
			outline: var(--border-width-l) solid var(--color-black-12);
		}

		@include tablet {
			display: flex;
			// flex-direction: column; // &__menu даже с overflow-y cо значением auto не будет давать возможность полноценно скроллить страницу при открытии модального окна. Чтобы это исправить, в &-list дабавляем margin-block со значением auto.
			justify-content: center; // Если центрировать через justify-content: center, то при переполнении (когда меню длиннее экрана) верхушка списка просто улетит за верхнюю границу и её невозможно будет увидеть. Браузер считает, что центр — это святое, и «обрезает» верх и низ.
			height: 100%;
			border-radius: 0;
			overflow-y: auto; // Делаем возможной прокрутку по вертикальной оси в рамках элемента header__menu.
		}

		&-list {
			display: flex;
			align-items: center;
			column-gap: 6px; // Рассчитал как 30 - 24, т.е. от элемента n до границы n-1 минус от текстового содержимое элемента n-1 до его правой границы.

			@include tablet {
				flex-direction: column;
				row-gap: 16px;
				margin-block: auto; // Вертикальное центирование элементов благодаря внешним отступам margin.
			}
		}

		&-link {
			padding: fluid-to-laptop(14, 12) fluid-to-laptop(24, 20);
			color: var(--color-gray-75);
			border-radius: var(--border-radius-s);

			@include hover {
				color: var(--color-white);
				background-color: var(--color-red-45);
			}

			&.is-active {
				color: var(--color-white);
				font-weight: 500;
				background-color: var(--color-black-10);
				pointer-events: none; // Отключим взаимодействие с актвной ссылкой.
			}

			@include tablet {
				font-size: 20px;
			}
		}
	}

	&__actions {
		display: flex;
		align-items: center;
		column-gap: 10px; /* Такие кликабельные элементы, как кнопки, должны иметь область нажатия не менее 44px. Поэтому из column-gap макету в 30px мы вычтем 10px по два раза. */
	}

	&__burger-button { // &__burger-button расположен внутри элемента с классом container. На container действует padding-inline со значением padding-x
		position: relative; // Даже без явного z-index, position: relative выводит элемент на новый "слой" над обычным потоком документа.
	}
}


/*
	Анимации в CSS начинаются с объявления групп правил ключевых кадров, которые опиываются в рамках так называемой директивы keyframes.
	Ключевые кадры - это понятие из мира видеомонтажа. Каждый кадр имеет определённое состояние в конкретную единицу времени.
	В CSS ключевые кадры описывают значение свойств в определённый промежуток времени выполнения анимации.
*/ 

// @keyframes move-to-right { // Сначала пишем имя директивы, начиная с символа "@", затем имя анимации (оно может быть любым).
// 	/* 
// 		Внутри, в фигурных скобках, пишутся группы правил, каждое из которых отвечает за определенный момент времени выполнения анимации.
// 		Вместо from и to можно задать значение в процентах от 0 до 100.
// 		Начальный ключевой кадр мы можем и не задавать вовсе. И за первый ключевой кадр будет взято изначальное состояние свойства элемента.
// 		При необходимости мы можем добавить сколь угодно ключевых кадров с привязкой к моменту от 0 до 100 процентов.
// 	*/

// 	from { // Начальный кадр анимации.
// 		translate: 0;
// 	}

// 	50% {
// 		rotate: 45deg;
// 	}

// 	to { // Конченый кадр анимации.
// 		translate: 75vw;
// 	}
// }

// Подсвойства, которые отвечают за конкретный параметр анимации
// .box {
// 	animation-name: move-to-right; // В нем мы пишем имя анимации, которые мы писсали просле объявления директивы keyframes.
// 	animation-duration: 1s; // Здесь мы указываем длительность анимации в секундах или миллисекундах.
// 	animation-delay: 0.5s; // Если мы хотим использовать задержку перед началом выполнения анимации, то используем свойства animation-delay. У animation-delay есть возможность указывать и отрицательные значения (например, -0,5s). Тогда вместо задержки перед началом анимация как бы запустится в фоне и фактически начнется не с самого начала.
// 	animation-iteration-count: 3; // В значении указывается целое число больше нуля, и именно такое количество раз теперь будет выполняться анимация после загрузки страницы. Также в значении мы можем указать ключевое слово Infinite, указывающее то, что анимация должна выполняться бесконечно.
// 	animation-timing-function: ease; // Свойство отвечает за скорость выполнения анимации. Значения абсолютно такие же, как и у transition-timing-function. Значения: ease-in, easy-out, easy-in-out, linear, cubic-beizer (по умолчанию easy).
// 	animation-direction: reverse; // C помощью него мы говорим браузеру, должна ли анимация выполняться в обратном порядке. Значения: reverse, alternate, alternate-reverse, (по умолчанию normal).
// 	animation-play-state: paused; // Позволяет ставить выполнение анимации на паузу. Значения: paused, (по умолчанию running)
// }

/*
	Scroll-driven Animations API позволяет сделать так, чтобы стадии изменения состояния элемента зависили не от фискированного времени сразу после загрузки страницы, а чтобы стадии изменения состояния завесели от текущего положения скролла страницы.
	CSS свойства из мира новых анимаций: 
	animation-timeline нужно для привязки анимации к прогрессу прокрутки страницы.
	animation-range позволяет менять состояние изменения гараздо быстрее.
	view-timeline-name: --fade-in-image; // Это свойство позволит связать прогресс будущей анимации с областью видимости текущего элемента в рамках области прокрутки.
	
	Разберем реальные кейсы:
*/

// 1. Прогресс скролла страницы

// @keyframes fill-progress {
// 	to {
// 		width: 100%;
// 	}
// }

// .header {
// 	position: fixed;
// 	top: 0;
// 	left: 0;
// 	width: 0;
// 	height: 10px;
// 	background-color: red;

// 	animation-name: fill-progress;
// 	animation-timing-function: linear;
// 	animation-timeline: scroll(); // animation-timeline нужно для привязки анимации к прогрессу прокрутки страницы.
// }


// 2. Фиксированная (”липкая”) шапка с анимацией при скролле вниз.

// @keyframes scrolling-header {
// 	to {
// 		height: 20px;
// 		box-shadow: 0 2px 2px rgb(0, 0, 0 / 0.5);
// 	} 
// }

// header {
// 	position: sticky;
// 	top: 0;
// 	left: 0;
// 	width: 100%;
// 	height: 40px;
// 	background-color: rgb(89, 89, 210);
// 	animation-name: scrolling-header;
// 	animation-fill-mode: both; // Чтобы после окончания анимации зациклить ее на последнем кадре, пропишем animation-fill-mode: both.
// 	animation-timeline: scroll();
// 	animation-range: 100px 200px; // Позволяет поменять состояние анимация быстрее. Первое число отвечает за начальную точку скролла, при которой анимация запуститься. А вторая - конечная точка скролла, при которой анимация завершится (в нашем случае зациклиться на последнем кадре).
// }

// 3. Плавное появление элементов при скролле страницы.

// @keyframes fade-in {
// 	from {
// 		translate: -25vw;
// 		opacity: 0;
// 	}
// }

// p {
// 	display: block;
// 	margin-inline: auto;

// 	animation-name: fade-in;
// 	animation-fill-mode: both;
// 	animation-timing-function: linear;
	
// 	view-timeline-name: --fade-in-image; // Это свойство позволит связать прогресс будущей анимации с областью видимости текущего элемента в рамках области прокрутки.
// 	animation-timeline: --fade-in-image; // И, чтобы это получилось, указываем animation-timeline: --fade-in-image.
// 	animation-range: 20% 50%; // Мы хотим, чтобы анимация запускалась, когда параграф частично появляется в видимой области прокрутки. 
// }
