html {
	&.is-lock {
		overflow: hidden; // <-- Нужно, чтобы скролл страницы блокировался, когда у нас открыто какое-то меню поверх сайта.
		scrollbar-gutter: auto !important; // Это вернет поведение к классическому: место под скролл будет появляться только тогда, когда он реально есть
	}
}

body {
	@include fluid-text(18, 14);

	display: flex;
	flex-direction: column;
	font-family: var(--font-family-base);
	color: var(--color-gray-60);
	background-color: var(--color-black-08);
}

main {
	flex-grow: 1; // <-- flex-grow: 1 прибивает футер к низу, заставляя основной контент («жадный» элемент) занимать всё свободное пространство между хедером и футером
}

h1, .h1, // <-- Зачем нужны утилитарные классы? Коротко: мы должны добиться и корректной иерархии, и визуального совпадения с макетом. Когда мы рашаем, какой уровень заголовка использовать для тега в разметке, мы должны оринтироваться не на макет, а на логику и текущую иерархию в контексте конкретного заголовка.
h2, .h2,
h3, .h3,
h4, .h4,
h5, .h5,
h6, .h6 {
	color: var(--color-white);
}

/* Шкала font-weight:
	100 — Thin/Hairline
	200 — Extra-Light
	300 — Light
	400 — Normal/Regular
	500 — Medium
	600 — Semi-Bold
	700 — Bold
	800 — Extra-Bold
	900 — Black/Heavy
*/

h1, .h1 { // <-- Самый крупный заголовок.
	@include fluid-text(58, 28);

	font-weight: 700;
}

h2, .h2 {
	@include fluid-text(48, 24);
	
	font-weight: 700;
}

h3, .h3 { // <-- Заголовок в последней секции перед футером. По макету прослеживается рассинхронизация уровней и иерархии заголовков. Для этих заголовков будет использоваться тег h2 c утилитарным классом h3.
	@include fluid-text(38, 20);
	
	font-weight: 700;
}

h4, .h4 { // <-- Заголовок карточек.
	@include fluid-text(24, 18);
	
	font-weight: 600;
}

h5, .h5 { // <-- Заголовок аккордеона.
	@include fluid-text(22, 18);

	font-weight: 500;
}

h6, .h6 { // <-- Заголовок футера.
	@include fluid-text(22, 18);

	font-weight: 600;
}

// Напишем комбинированный селектор для всех интерактивных элементов, которым потребуется добавить плаввность перехода.
a, 
button, 
label, 
input, 
textarea, 
select, 
svg * {
	transition-duration: var(--transition-duration);
}

a {
	color: inherit;

	@include hover {
		color: var(--color-red-45);
	}

	/*
		У ссылок по умолчанию есть подчеркивание (text-decoration).
		Убирать его для всех ссылок неправильно. 
		Если мы так сдалем, то ссылки в тексте будут выглядеть неотличимо от окружающего их текста.
		Мы применим хитрый подход: будем сбрасывать подчеркивание всем ссылкам, у которых есть атрибут class.
	*/

	&[class] { 
		text-decoration: none; // <-- Таким образом мы оставляем подчеркивания у ссылок, которые могут появляться в любом месте в рамках тексовых блоков, а для ссылок, нужных нам (с какими-то классами в разметке), text-decoration: none будет автоматически применяться.
	}
}

:focus-visible { // <-- Чтобы не тригерить лишний раз классическое состояние фокуса, через селектор по псевдоклассу зафиксируем стили для состояния фокуса.
	@include focus-visible;
}