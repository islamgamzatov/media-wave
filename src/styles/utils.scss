// Данный файл послужит для утилитарных классов.

.container { // Для задания параметров контентного контейнера зададим утилитарный класс container.
	width: 100%; // Блок container будет занимать все доступное ему пространство родителя.
	max-width: calc(var(--conttainer-width) + var(--container-padding-x) * 2); // Например, ширина Viewport = 1440. --conttainer-width = 1200. Вместе с отступами 1232 (с четом padding-inline)
	margin-inline: auto; // <-- Нужно для горизонтального центрирования элемента.
	padding-inline: var(--container-padding-x); // <-- Такой связной из max-width и padding-inline мы добьемся полного совпадания ширины контентного контейнера с макетом.
}

/* Зачем нужно было делать миксин visually-hidden? Почему нельзя было оставить один утилитарный класс?
	Мы миксин visually-hidden иногда будем вызывать опционально (на определенных диапазонах экранов). 
	И, чтобы избежать костылей в разметке, мы будем включать visually-hidden миксин в местах, где у нас нужно визуально скрыть элемент на определенном дивпазоне.
*/
.visually-hidden { // <-- С помощью этого класса мы будем скрывать элемент, оставляя его доступным для скринридеров.
	@include visually-hidden;
}

// Утилитарные классы для полного сокрытия элементов на определенных диапазонах экрана.
.visible-tablet {
	@include tablet-above {
		display: none !important; // <-- Ключевое слово !important считается плохой практикой, но для утилитарных классов его можно и нужно использовать.
	}
}

.hidden-tablet {
	@include tablet {
		display: none !important; // <-- Ключевое слово !important считается плохой практикой, но для утилитарных классов его можно и нужно использовать.
	}
}

.visible-mobile {
	@include mobile-above {
		display: none !important; // <-- Ключевое слово !important считается плохой практикой, но для утилитарных классов его можно и нужно использовать.
	}
}

.hidden-mobile {
	@include mobile {
		display: none !important; // <-- Ключевое слово !important считается плохой практикой, но для утилитарных классов его можно и нужно использовать.
	}
}